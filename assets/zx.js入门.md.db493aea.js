import{_ as a,o as s,c as e,O as t}from"./chunks/framework.56b4393c.js";const m=JSON.parse('{"title":"zx.js入门","description":"","frontmatter":{},"headers":[],"relativePath":"zx.js入门.md","filePath":"zx.js入门.md"}'),l={name:"zx.js入门.md"},n=t(`<h1 id="zx-js入门" tabindex="-1">zx.js入门 <a class="header-anchor" href="#zx-js入门" aria-label="Permalink to &quot;zx.js入门&quot;">​</a></h1><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><p>使用如下命令全局安装zx，以便在任何文件夹内使用：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">npm i -g zx</span></span></code></pre></div><h2 id="第一个示例" tabindex="-1">第一个示例 <a class="header-anchor" href="#第一个示例" aria-label="Permalink to &quot;第一个示例&quot;">​</a></h2><p>新建一个文件例如ls.mjs。编辑内容如下：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">import { $ } from &quot;zx&quot;;</span></span>
<span class="line"><span style="color:#A6ACCD;">$.verbose = false;</span></span>
<span class="line"><span style="color:#A6ACCD;">const output = (await $\`ls\`).stdout.trim();</span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(output);</span></span></code></pre></div><p>然后运行： zx ls.mjs</p><h2 id="代码解释" tabindex="-1">代码解释 <a class="header-anchor" href="#代码解释" aria-label="Permalink to &quot;代码解释&quot;">​</a></h2><p>$.verbose默认为true，会输出被调用的shell命令本身，我们这里设置为false。</p><p>$符号的作用是调用shell命令，大多数命令的调用都是异步的，所以加上await。</p><p>有些命令是用于执行操作，没有输出，例如mkdir、rename等。而有些命令我们是需要得到其输出结果的，例如ls、cat等。对于需要得到结果的命令，使用stdout（）函数以字符串的形式取回命令的输出结果，这相当于shell的重定向操作。最后，由于命令输出结果可能会在最后一行包含空白行，所以我们使用trim（）方法去掉字符串的空白行。</p>`,12),o=[n];function p(r,i,c,d,h,_){return s(),e("div",null,o)}const x=a(l,[["render",p]]);export{m as __pageData,x as default};
